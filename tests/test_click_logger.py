import importlib.util  # Load the production script whose filename starts with a numeral.
import json  # Inspect JSON generated by the persistence helper.
import sys  # Manipulate sys.modules for the dynamic import.
from pathlib import Path  # Build filesystem paths in a cross-platform manner.
from tempfile import TemporaryDirectory  # Create isolated directories for filesystem tests.
import unittest  # Provide the lightweight test harness requested.
from unittest.mock import patch  # Stub out matplotlib show so no windows pop up.

import matplotlib  # Use a non-interactive backend for smoke tests.
import numpy as np  # Generate artificial AFM matrices for controlled scenarios.

matplotlib.use("Agg")  # Ensure all matplotlib usage is headless during the tests.


def load_click_module():
    """Dynamically import the production module so the tests can access its functions."""
    module_path = Path(__file__).resolve().parents[1] / "1_click_hole_coordinates.py"
    spec = importlib.util.spec_from_file_location("click_module", module_path)
    module = importlib.util.module_from_spec(spec)
    sys.modules["click_module"] = module
    assert spec.loader is not None  # Hint to type-checkers.
    spec.loader.exec_module(module)
    return module


CLICK_MODULE = load_click_module()


class ClickLoggerTests(unittest.TestCase):
    """Unit tests covering JSON persistence and the interactive smoke flow."""

    def test_write_click_data_creates_json_file(self) -> None:
        """Verify that the helper writes JSON data to disk with expected contents."""
        with TemporaryDirectory() as tmp_dir:
            json_path = Path(tmp_dir) / "clicks.json"
            sample_data = {"scan.npy": {"clicked_points": [(1, 2)], "total_number_of_clicked_points": 1}}
            CLICK_MODULE.write_click_data(str(json_path), sample_data)
            with open(json_path, "r", encoding="utf-8") as file_handle:
                payload = json.load(file_handle)
            # JSON serialises tuples as lists, so normalise the payload before asserting equality.
            parsed = {}
            for key, value in payload.items():
                parsed[key] = dict(value)
                parsed[key]["clicked_points"] = [tuple(point) for point in parsed[key]["clicked_points"]]
            self.assertEqual(parsed, sample_data)

    def test_validate_matrix_shape_handles_empty_and_valid_cases(self) -> None:
        """Confirm that empty matrices are rejected and regular 2D matrices pass."""
        empty_matrix = np.array([])
        valid_matrix = np.zeros((10, 10))
        self.assertFalse(CLICK_MODULE.validate_matrix_shape(empty_matrix, "empty.npy"))
        self.assertTrue(CLICK_MODULE.validate_matrix_shape(valid_matrix, "valid.npy"))

    @patch("matplotlib.pyplot.show")
    def test_process_file_smoke(self, mock_show) -> None:
        """Run process_file on a synthetic .npy file and ensure it completes without clicks."""
        with TemporaryDirectory() as tmp_dir:
            CLICK_MODULE.ensure_directory_exists(tmp_dir)
            npy_path = Path(tmp_dir) / "synthetic.npy"
            np.save(npy_path, np.zeros((5, 5), dtype=float))
            json_path = Path(tmp_dir) / "out.json"
            result = CLICK_MODULE.process_file(str(npy_path), {}, str(json_path))
            self.assertEqual(result, [])
            mock_show.assert_called_once()


if __name__ == "__main__":
    unittest.main()
